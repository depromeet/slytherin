# 밥토리(Babtori) 추천/검색 시스템 아키텍처 의사결정 (ADR)

- **작성일:** 2025-10-25
- **주요 내용:** 추천 및 검색 시스템의 핵심 컴포넌트(벡터 생성, 저장, 처리)에 대한 기술적 트레이드오프를 비교하고 최종 아키텍처를 결정합니다.

---

## 1. 임베딩 벡터 생성 방식: API vs. 로컬 라이브러리

### 🎯 결정: Hosted API (Naver CLOVA Studio) 사용

- **배경:** 가게 정보(텍스트)를 수치화된 벡터(Vector)로 변환하는 핵심 엔진을 선택해야 했습니다.
- **고려된 대안:**
    1.  **로컬 라이브러리 (e.g., Hugging Face KoSimCSE)**
        - **장점:** API 호출 비용이 0원이며 네트워크 지연이 없습니다.
        - **단점:** 임베딩 모델(최소 500MB~1GB+)을 서버 메모리에 상주시켜야 합니다. 현재 `t3.small` (2GB RAM) 인스턴스 환경에서 OS + JVM 실행만으로도 이미 한계에 가까워, 모델 로드 시 **100% `OutOfMemory(OOM)` 오류가 발생**합니다.
    2.  **Hosted API (e.g., Naver CLOVA Studio)**
        - **장점:** 현재 서버 자원(`t3.small`)을 전혀 사용하지 않고(HTTP 요청) 벡터를 생성할 수 있습니다. 사용한 만큼만 지불(Pay-as-you-go)하여 초기 비용이 압도적으로 저렴합니다.
        - **단점:** API 호출 비용 및 네트워크 지연이 발생합니다.
- **선택 사유:**
    - **`t3.small` 인프라 환경**을 고려할 때, 'Hosted API' 방식이 **유일하게 실행 가능한 현실적인 대안**입니다.
    - 서버 인스턴스를 `t3.medium` 이상으로 업그레이드하는 **고정 비용**이, API를 호출하는 **변동 비용**보다 초기 서비스 단계에서 훨씬 부담이 큽니다.

---

## 2. 벡터 데이터 모델: 단일 AI 모델 vs. 하이브리드

### 🎯 결정: `embedding_vector` (AI)와 `manual_vector` (수동)를 모두 사용하는 하이브리드 방식 채택

- **배경:** 시스템은 "혼밥 난이도 3배" 같은 **명시적 가중치**와 "조용한 분위기" 같은 **추상적 의미**를 모두 처리해야 했습니다.
- **고려된 대안:**
    1.  **`embedding_vector` (1024차원)만 사용**
        - **장점:** 구현이 단순하며, "조용한", "가성비 좋은" 등 추상적인 의미 검색에 강력합니다.
        - **단점:** AI가 생성한 '블랙박스' 벡터이므로, "N번 차원 = 혼밥 난이도"라고 특정할 수 없어 **명시적 가중치 부여가 불가능**합니다.
    2.  **`manual_vector` (10차원)만 사용**
        - **장점:** `[0]=혼밥난이도`, `[1]=1인석유무`처럼 개발자가 직접 차원을 정의하므로, **"혼밥 난이도 x3" 같은 가중치 제어가 완벽**합니다.
        - **단점:** "조용한 분위기"처럼 텍스트의 문맥적, 추상적 의미를 전혀 이해하지 못합니다.
- **선택 사유:**
    - 두 벡터의 장단점이 명확히 상호 보완됩니다.
    - `manual_vector`로 **'유사 맛집 추천(case 1)'**의 명시적 가중치를 처리하고, `embedding_vector`로 **'의미 기반 검색'**을 처리하여 기획 의도를 모두 만족시킵니다.

---

## 3. 벡터 데이터 저장 위치: 테이블 분리 vs. 통합

### 🎯 결정: `Store` 테이블 내에 `embedding_vector`, `manual_vector` 컬럼으로 함께 저장

- **배경:** 1:1 관계인 벡터 데이터(`manual_vector`, `embedding_vector`)를 `Store` 테이블과 어떻게 관계 맺을지 스키마를 설계해야 했습니다.
- **고려된 대안:**
    1.  **`StoreVector` 테이블로 1:1 분리**
        - **장점:** 데이터베이스 정규화 원칙(책임 분리)에 부합하며, `Store` 테이블이 비대해지는 것을 막습니다.
        - **단점:** 벡터 검색(`ORDER BY vector <=> ...`) 시, 가게 이름/주소 등 부가 정보를 가져오기 위해 **항상 `Store` 테이블과 `JOIN`이 발생**합니다. 이는 데이터가 많아질수록 **검색 성능에 치명적인 병목**이 됩니다.
    2.  **`Store` 테이블에 컬럼으로 포함**
        - **장점:** 벡터 검색 시 `JOIN`이 전혀 필요 없어 **압도적인 검색 속도를 확보**할 수 있습니다. 1:1 관계이므로 데이터 관리가 복잡하지 않습니다.
        - **단점:** `Store` 테이블의 책임이 늘어나고 무거워집니다.
- **선택 사유:**
    - `pgvector`를 사용하는 시스템의 **최우선 목표는 '빠른 벡터 검색'**입니다.
    - DB 정규화를 일부 포기하더라도 **검색 성능을 최적화**하기 위해 `JOIN`을 원천 제거하는 방식을 선택합니다.

---

## 4. `embedding_vector` 생성 시점: 동기 vs. 비동기

### 🎯 결정: `@Scheduled`를 이용한 비동기 배치(Batch) 처리

- **배경:** `embedding_vector` 생성은 외부 CLOVA API 호출(I/O)을 필요로 하며, 이는 수백ms에서 수 초의 시간이 걸릴 수 있습니다.
- **고려된 대안:**
    1.  **가게 생성/수정 시 동기(Sync) 처리**
        - **장점:** 구현이 단순하며, 데이터가 즉시 반영됩니다.
        - **단점:**
            1.  CLOVA API가 느리면 **가게 생성/수정 API 응답이 1~2초씩 지연**되어 사용자 경험(UX)을 심각하게 저해합니다.
            2.  CLOVA API가 장애가 나면 **가게 생성/수정 핵심 기능 자체가 실패**합니다. (치명적)
    2.  **비동기 배치(Async) 처리**
        - **장점:**
            1.  가게 생성/수정 API가 0.1초 내로 즉시 응답하여 UX가 향상됩니다.
            2.  CLOVA API 장애가 서비스의 핵심 기능(가게 생성)에 영향을 주지 않습니다. **(장애 격리)**
        - **단점:** 구현이 복잡해지며, 데이터 반영에 최대 10분(배치 주기)의 지연이 발생합니다.
- **선택 사유:**
    - **API 응답 속도와 장애 격리(Resilience)**가 데이터 즉시성보다 훨씬 중요합니다.
    - `manual_vector`는 동기로 즉시 생성되므로, '명시적 가중치 추천'은 즉시 동작합니다. '의미 기반 검색'만 10분 지연되는 것은 허용 가능한 트레이드오프입니다.

---

## 5. 비동기 처리 구현 방식: Status 컬럼 vs. Task Queue vs. Cursor

### 🎯 결정: `Store` 테이블에 `embedding_status` 컬럼을 추가하는 Status 방식

- **배경:** 4번 결정(비동기 배치)을 구현하는 구체적인 방법론을 선택해야 했습니다.
- **고려된 대안:**
    1.  **Status 컬럼 방식 (`Store.embedding_status`)**
        - **개념:** `Store` 테이블에 `embedding_status` 컬럼(`PENDING`, `COMPLETED`, `FAILED`)을 추가하고, 배치에서 `WHERE embedding_status = 'PENDING'`으로 조회하여 처리합니다.
        - **장점:**
            1.  **(단순성)** 구현이 매우 단순합니다. 컬럼 1개만 추가하면 됩니다.
            2.  **(성능)** `embedding_status` 컬럼에 **인덱스를 생성하면 Full Scan이 아닌 인덱스 스캔**(O(log n))으로 빠르게 조회됩니다.
            3.  **(정합성)** Store와 처리 상태가 항상 같은 row에 있어 데이터 정합성 관리가 쉽습니다.
            4.  **(실패 처리)** `FAILED` 상태로 표시하고, 재시도 시 `PENDING`으로 되돌리면 자동 재처리됩니다.
            5.  **(삭제 처리)** Store가 삭제되면 상태도 자동으로 함께 삭제됩니다. (별도 CASCADE 불필요)
        - **단점:**
            1.  **(SoC)** `Store` 테이블에 "임베딩 처리 상태"라는 부가 책임이 추가되어 관심사 분리 원칙에 일부 위배됩니다.
            2.  **(확장성)** 수백만 개 이상의 Store가 있고 대부분이 `PENDING` 상태라면, 인덱스가 있어도 조회 성능이 저하될 수 있습니다. (하지만 **밥토리는 초기 서비스**로 이 상황에 해당하지 않음)
        - **적합한 사례:**
            - **초기~중기 서비스** (Store 수천~수만 개)
            - 단순하고 직관적인 구현을 선호하는 경우
            - 처리 대상이 전체의 일부인 경우 (대부분은 `COMPLETED` 상태)
    2.  **Task Queue 테이블 방식 (`StoreEmbeddingQueue` 테이블 분리)**
        - **개념:** "처리해야 할 대상"(`store_id`)만 별도 큐 테이블에 저장합니다. 배치는 오직 큐 테이블만 읽습니다.
        - **장점:**
            1.  **(SoC)** `Store` 테이블의 책임이 순수하게 유지됩니다.
            2.  **(확장성)** 수백만 개 Store가 있어도, 큐 테이블은 수십~수백 건만 담고 있어 매우 빠릅니다.
            3.  **(분산 처리)** 여러 서버가 큐를 나눠서 처리하기 용이합니다.
        - **단점:**
            1.  **(복잡성)** Queue 엔티티, Repository, Store 생성/수정 시 Queue 추가 로직, CASCADE 설정 등 **구현 복잡도가 크게 증가**합니다.
            2.  **(정합성)** Queue와 Store 간 동기화를 별도로 관리해야 합니다. (e.g., Store는 삭제됐는데 Queue는 남아있는 경우)
            3.  **(과도한 최적화)** **밥토리의 초기 규모(수천 개)에서는 Status 방식도 충분히 빠릅니다.** 복잡성 대비 실질적 성능 이득이 미미합니다.
        - **적합한 사례:**
            - **대규모 서비스** (수십만~수백만 건의 PENDING 데이터)
            - 분산 처리가 필요한 경우
            - 메시지 큐(Kafka, RabbitMQ) 기반 아키텍처
    3.  **Cursor 방식 (`updatedAt > lastCompletedAt`)**
        - **개념:** "마지막으로 성공적으로 처리된 시점(`lastCompletedAt`)"을 기록하고, 이후 변경된 데이터만 조회하여 처리합니다.
        - **장점:** 대량 데이터 일괄 동기화에 효율적입니다.
        - **단점:**
            1.  **(실패 처리)** 100건 중 1건이 실패해도 커서를 어떻게 이동시킬지 애매합니다. 실패한 항목만 재시도하는 로직이 복잡합니다.
            2.  **(상태 관리)** 개별 작업의 상태(`PENDING`, `FAILED`)를 추적할 수 없습니다.
        - **적합한 사례:**
            - 대량 데이터를 한 번에 동기화하는 배치 (e.g., Elasticsearch 전체 재색인)
            - 실패가 거의 발생하지 않는 안정적인 환경 (로컬 DB → 로컬 Elasticsearch)
- **선택 사유:**
    - **YAGNI 원칙(You Aren't Gonna Need It)**: 밥토리는 초기 서비스로 수백~수천 개의 Store를 다룹니다. 이 규모에서는 **인덱스를 적절히 사용한 Status 방식도 충분히 빠릅니다.** (조회 시간 < 10ms)
    - **실용성 > 이론적 완벽함**: Task Queue 방식은 이론적으로 더 우아하지만, **복잡성 증가 대비 실질적 성능 이득이 미미**합니다. 서비스가 수십만 개 규모로 성장한 후에 마이그레이션해도 늦지 않습니다.
    - **실패 처리**: Status 방식도 `FAILED` 상태로 개별 실패를 추적할 수 있으며, 재시도 로직(`FAILED` → `PENDING`)도 간단합니다.
    - **실제 서비스 사례**: Airbnb, Uber 등 대규모 서비스도 초기에는 Status 컬럼 방식을 사용하다가, 정말 필요할 때 Queue 시스템으로 마이그레이션합니다.
    - **기술 부채 최소화**: 불필요하게 복잡한 시스템은 오히려 기술 부채가 됩니다. **지금 당장 필요한 만큼만 구현**합니다.
